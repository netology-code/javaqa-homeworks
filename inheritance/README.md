# Домашнее задание к занятию «3.5. Наследование и расширяемость систем. Проблемы наследования»

В качестве результата пришлите ссылки на ваши [GitHub](https://github.com/)-проекты в личном кабинете студента на сайте [netology.ru](https://netology.ru).

**Важно**: все задачи этого занятия можно делать в разных репозиториях. Однако, вы можете оформить домашнее задание и в одном репозитории, если решаете задачи последовательно в разных ветках.

**Важно**: если у вас что-то не получилось, то оформляйте `Issue` [по установленным правилам](../report-requirements.md).

---
## Как сдавать задачи

1. Ознакомьтесь с [особенностями Lombok](../extra/lombok/inheritance.md) при использовании наследования.
1. Ознакомьтесь с дополнительными материалами о [`static`](../extra/static.md) и [`reflection`](../extra/reflection.md).
1. Инициализируйте на своём компьютере пустой `Git`-репозиторий.
1. Добавьте в него готовый файл [.gitignore](../.gitignore).
1. Добавьте в этот же каталог необходимые файлы (`pom.xml` и другие).
1. Сделайте ветки для первой задачи (после того, как сделаете первую задачу, на её основе создайте ветку для второй задачи).
1. Создайте публичный репозиторий на [GitHub](https://github.com/) и свяжите свой локальный репозиторий с удалённым.
1. Сделайте пуш (удостоверьтесь, что ваш код и обе ветки появились на [GitHub](https://github.com/)).
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru).
1. В этом домашнем задании все задачи являются обязательными.

---
## Задача №1 - "Менеджер Товаров"

На основании проекта из лекции необходимо реализовать менеджер товаров, который умеет:

1. добавлять товары в репозиторий;
1. искать товары (репозиторий должен отдать все товары, а менеджер уже потом по ним ищет*).

*Примечание: это не самый эффективный способ. Когда мы будем проходить базы данных, поговорим, что это лучше делать там (ещё лучше - воспользоваться специализированным решением).

#### Что нужно сделать
* Разработайте
    1. базовый класс `Product`, содержащий `id`, `название`, `стоимость`;
    1. два унаследованных от `Product` класса: `Book` (с полями `название`* и `автор`) и `Smartphone` (с полями `название`* и `производитель`);
    1. репозиторий, позволяющий сохранять `Product`'ы, получать все сохранённые `Product`'ы и удалять по `id`;
    1. менеджер, который умеет добавлять `Product`'ы в репозиторий и осуществлять поиск по ним.

*Примечание: надеемся, вы догадались, что название и так уже есть в классе `Product`.

#### Как осуществлять поиск

У менеджера должен быть метод `searchBy(String text)`, который возвращает массив найденных товаров.

```java
public class ProductManager {
  // добавьте необходимые поля, конструкторы и методы

  public Product[] searchBy(String text) {
    // ваш код
  }

  public boolean matches(Product product, String search) {
    // ваш код
  }
}
```

Менеджер при переборе всех продуктов, хранящихся в репозитории, должен для каждого продукта вызывать собственный метод `matches`, который проверяет, соответствует ли продукт поисковому запросу.

Проверка соответствия типа объекта проводится с помощью `instanceof` - для книги по полям `название` и `автор`, для смартфона - `название` и `производитель`.

Пример того, как это можно сделать:

```java
if (product instanceof Book) {
    Book book = (Book) product;
    if (book.getName().equalsIgnoreCase(search)) {
      return true;
    }  
    if (book.getAuthor().equalsIgnoreCase(search)) {
      return true;
    }  
    return false;
}
```

Q: Откуда взять информацию о методе `equalsIgnoreCase`?

A: Вам нужно посмотреть [документацию](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#method.summary) на класс `String`* (ведь `book.getName()` возвращает объект класса `String`) и подобрать необходимые методы (на ваше усмотрение). Это очень важно: знать, какие классы есть в стандартной библиотеке и какие методы они предоставляют! 

*Примечание: воспринимайте пока `CharSequence` как `String`.

<details>
  <summary>Подсказка</summary>
  
```java
public class ProductManager {
  // добавьте необходимые поля, конструкторы и методы

  public Product[] searchBy(String text) {
    Product[] result = new Product[0];
    for (Product product: repository.findAll()) {
      if (matches(product, text)) {
        Product[] tmp = new Product[result.length + 1];
        // используйте System.arraycopy, чтобы скопировать всё из result в tmp
        tmp[tmp.length - 1] = product;
        result = tmp;
      }
    }
    return result;
  }

  public boolean matches(Product product, String search) {
    // ваш код
  }
}
```
</details>

#### Требования к проекту
1. Создайте отдельную ветку (не делайте домашнее задание в `main`!).
1. Подключите плагин `Surefire` так, чтобы сборка падала в случае отсутствия тестов.
1. Подключите плагин `JaCoCo` в режиме генерации отчётов (обрушивать сборку по покрытию не нужно).
1. Реализуйте нужные классы и методы.
1. Напишите автотесты на метод поиска (только на метод поиска в менеджере), добившись `100%` покрытия по `branch`'ам* (вспомните, что мы говорили про тестирование методов, возвращающих набор значений).
1. Подключите `CI` на базе `Github Actions` и выложите всё на [GitHub](https://github.com/).

*Примечание: использовать ли `Mockito` - мы оставляем на ваше усмотрение.

**Итого:** у вас должен быть репозиторий на [GitHub](https://github.com/), в котором расположен ваш `Java`-код + `CI` на базе `Github Actions` (в `main`, по сути, должен быть только `pom.xml`).

---
## Задача №2 - "Менеджер Товаров" (Rich Model)

#### Легенда

Порой объекты, моделирующие предметную область, называют "моделями". Достаточно часто модели делают "глупыми", то есть не содержащими никакой логики.

Но есть и другой подход, который позволяет делать "умные", или "богатые", модели (Rich Model), которые могут уже содержать определённую логику.

#### Что нужно сделать
1. Создайте новую ветку на базе ветки, в которой вы решали первую задачу.
1. Реализуйте в классе `Product` метод `public boolean matches(String search)` (аргумент `Product product` на вход уже не требуется - поможет `this` внутри метода), который определяет, подходит ли продукт поисковому запросу исходя из названия.
1. Переопределите этот метод в дочерних классах, чтобы они сначала вызывали родительский метод, и если родительский метод возвращает `false`, только тогда проводили дополнительные проверки (`Book` - по автору, `Smartphone` - по производителю).
1. Уберите из менеджера все `instanceof` и метод `matches`, так как теперь у вас "умные" модели и благодаря переопределению методов вам этот код больше не нужен.
1. Однако, теперь вам нужны `unit`-тесты на методы ваших умных моделей - напишите их.
1. Удостоверьтесь, что ранее написанные тесты на менеджер (из решения первой задачи) проходят успешно, и тестовое покрытие на прежнем уровне.
 
<details>
  <summary>Подсказка №1</summary>
  
```java
public class ProductManager {
  // добавьте необходимые поля, конструкторы и методы

  public Product[] searchBy(String text) {
    Product[] result = new Product[0];
    for (Product product: repository.findAll()) {
      if (product.matches(text)) {
        Product[] tmp = new Product[result.length + 1];
        // используйте System.arraycopy, чтобы скопировать всё из result в tmp
        tmp[tmp.length - 1] = product;
        result = tmp;
      }
    }
    return result;
  }
}
```
</details>

<details>
  <summary>Подсказка №2 (про оператор "||")</summary>
  
У нас есть замечательный логический оператор `||`, который работает следующим образом: вычисляет правую часть выражения только в случае, если левая равна `false`.
  
```java
public class Book {
  // ваши поля, конструкторы, методы
  public boolean matches(String search) {
    return super.matches(search) || ... ваше выражение ...;
  }
}
```

Никто не говорит, что вариант выше лучше этого (наоборот, этот легче тестировать и отлаживать):
```java
public class Book {
  // ваши поля, конструкторы, методы
  public boolean matches(String search) {
    if (super.matches(search)) {
      return true;
    }
    return ... ваше выражение ...;
  }
}
```

Но вы должны знать оба варианта.
</details>

**Итого:** у вас должен быть репозиторий на [GitHub](https://github.com/), в котором расположен ваш `Java`-код + `CI` на базе `Github Actions` (в `main`, по сути, должен быть только `pom.xml`).
