# Домашнее задание к занятию «Объектно-ориентированное программирование и проектирование»

В качестве результата пришлите ссылки на ваши GitHub-проекты в личном кабинете студента на сайте [netology.ru](https://netology.ru).

Все задачи этого занятия можно делать в одном репозитории.

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

Вы можете делать все задачи этого занятия в одном репозитории (если делаете их последовательно).

## Как сдавать задачи

1. Инициализируйте на своём компьютере пустой Git-репозиторий
1. Добавьте в него готовый файл [.gitignore](../.gitignore)
1. Добавьте в этот же каталог необходимые файлы
1. Сделайте необходимые коммиты
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub)
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru)
1. Задачи, отмеченные, как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными)

## Задача №1 - "Кондиционер: теплее и холоднее"

### Легенда

В проект умного дома решили добавить возможность увеличивать температуру на один градус и уменьшать.

Создайте на базе проекта с лекции собственный проект, в котором:
1. Подключите плагин Surefire так, чтобы сборка падала в случае отсутсвия тестов
1. Подключите плагин JaCoCo в режиме генерации отчётов (обрушать сборку по покрытию не нужно)
1. Удалите `Condition` и тесты к нему
1. Переименуйте `ConditionAdvanced` в `Condition` (Shift + F6 на имени класса)
1. Реализуйте методы `public void increaseCurrentTemperature()` и `public void decreaseCurrentTemperature()`
1. Напишите автотесты на методы из предыдущего пункта, добившись 100% покрытия по branch'ам
1. Подключите CI на базе Github Actions и выложите всё на Github

Как должны работать методы:
* `increaseCurrentTemperature` - увеличивает температуру на 1 до тех пор, пока не достигнута максимальная (`maxTemperature`), последующие (после достижения `maxTemperature`) вызовы метода не должны ничего менять в состоянии объекта
* `decreaseCurrentTemperature` - уменьшает температуру на 1 до тех пор, пока не достигнута минимальная (`minTemperature`), последующие (после достижения `minTemperature`) вызовы метода не должны ничего менять в состоянии объекта

Важно: используйте Early Exit.

**Важно**: один вызов метода должен приводить к переключению на один градус (если не достигнут min/max)!

Итого: у вас должен быть репозиторий на GitHub, в котором расположен ваш Java-код, + CI на базе Github Actions

## Задача №2 - "Радиоман"

### Легенда

В рамках проекта по созданию "Умного дома" у нас появился очень важный клиент, которых хочет кастомную доработку: он очень любит радио, поэтому нам нужно научиться управлять радио.

Что нужно сделать: по аналогии с кондиционером создайте класс `Radio`, в котором храните следующие поля:
1. Номер текущей (прослушиваемой) радиостанции
1. Громкость звука

Требования к работе с радиостанциями:
1. Номер текущей радиостанции изменяется в пределах от 0 до 9
1. Если текущая радиостанция - 9 и клиент нажал на кнопку `next` (следующая) на пульте, то текущей должна стать 0-ая
1. Если текущая радиостанция - 0 и клиент нажал на кнопку `prev` (предыдущая) на пульте, то текущей должна стать 9-ая
1. Клиент должен иметь возможность выставлять номер радиостанции с цифрового пульта (вводя числа 0 - 9)

Требования к работе с уровнем громкости звука:
1. Клиент должен иметь возможность увеличивать и уменьшать уровень громкости звука (в пределах от 0 до 10)*
1. Если уровень громкости звука достиг максимального значения, то дальнейшее нажатие на `+` не должно ни к чему приводить
1. Если уровень громкости звука достиг минимального значения, то дальнейшее нажатие на `-` не должно ни к чему приводить

Примечание*: на следующей паре мы поговорим, почему здесь 10

**Важно**: один вызов метода должен приводить к переключению на одну радиостанцию!

Создайте на базе проекта с лекции собственный проект (вы можете использовать проект из предыдущей задачи), в котором:
1. Подключите плагин Surefire так, чтобы сборка падала в случае отсутсвия тестов
1. Подключите плагин JaCoCo в режиме генерации отчётов (обрушать сборку по покрытию не нужно)
1. Реализуйте нужные классы и методы
1. Напишите автотесты на методы, содержащие логику, добившись 100% покрытия по branch'ам
1. Подключите CI на базе Github Actions и выложите всё на Github

Итого: у вас должен быть репозиторий на GitHub, в котором расположен ваш Java-код.

## Задача №3 (необязательная) - "Цикломатическая сложность кода"

Важно: данная задача не является обязательной! Её не выполнение не влияет на получение зачёта по ДЗ.

### Легенда

Когда вы разбирались с JaCoCo, одним из счётчиков являлся счётчик, ответственный за подсчёт сложности кода.

На базе значения этой метрики можно вычислить количество unit-тестов, необходимых для покрытия определённого метода.

Настройте JaCoCo (если требуется) на подсчёт этой метрики для второй задачи (нас интересуют только методы для обработки `next` и `prev`) и удостоверьтесь, что для этих методов кол-во ваших unit-тестов совпадает с рекомендациями метрики.

В `README.md` репозитория второй задачи опишите:
1. Формулу вычисления количества unit-тестов на основании значений, генерируемых JaCoCo
1. Рекомендуемый порог цикломатической сложности кода (необходимо провести небольшое исследование)

В качестве отправной точки при проведении ваших исследований используйте:
1. Сайт JaCoCo
1. Википедию ([статья о цикломатической сложности кода](https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C))
